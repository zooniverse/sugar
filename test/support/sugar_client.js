// Generated by CoffeeScript 2.7.0
var Bluebird, SugarClient;

Bluebird = require('bluebird');

SugarClient = class SugarClient {
  constructor(sugar, query) {
    var binding, client, connection, i, len, method, methods, primus;
    connection = `http://localhost:${sugar.port}`;
    if (query) {
      connection += `?${query}`;
    }
    primus = sugar.primus;
    client = primus.Socket(connection);
    binding = {sugar, primus, client};
    methods = ['spark', 'ping', 'subscribeTo', 'unsubscribeFrom', 'sendEvent', 'keepAliveTimer', 'hasResponse'];
    for (i = 0, len = methods.length; i < len; i++) {
      method = methods[i];
      client[method] = this[method].bind(binding);
    }
    this.listenTo(client);
    return client;
  }

  listenTo(client) {
    return client.on('data', client.hasResponse);
  }

  spark() {
    var deferred;
    deferred = Bluebird.defer();
    this.client.id((id) => {
      return deferred.resolve(this.primus.spark(id));
    });
    return deferred.promise;
  }

  ping() {
    var deferred;
    deferred = Bluebird.defer();
    this.client.write(`primus::ping::${+new Date()}`);
    this.client.once('incoming::pong', function() {
      return deferred.resolve();
    });
    return deferred.promise;
  }

  subscribeTo(channel) {
    var deferred;
    deferred = Bluebird.defer();
    this.client.write({
      action: 'Subscribe',
      params: {
        channel: channel
      }
    });
    this.client.once(`subscribedTo::${channel}`, function() {
      return deferred.resolve();
    });
    return deferred.promise;
  }

  unsubscribeFrom(channel) {
    var deferred;
    deferred = Bluebird.defer();
    this.client.write({
      action: 'Unsubscribe',
      params: {
        channel: channel
      }
    });
    this.client.once(`unsubscribedFrom::${channel}`, function() {
      return deferred.resolve();
    });
    return deferred.promise;
  }

  sendEvent(opts = {}) {
    var base, deferred;
    deferred = Bluebird.defer();
    (base = this.client).eventId || (base.eventId = 0);
    this.client.eventId += 1;
    opts.data || (opts.data = {});
    opts.data.id = this.client.eventId;
    this.client.once(`sentEvent::${opts.data.id}`, function(payload) {
      return deferred.resolve(payload);
    });
    this.client.write({
      action: 'Event',
      params: opts
    });
    return deferred.promise;
  }

  keepAliveTimer() {
    return this.client.spark().then(function(spark) {
      var ref;
      return (ref = spark.keepAliveTimer) != null ? ref._monotonicStartTime : void 0;
    });
  }

  hasResponse(data) {
    var key;
    key = data.type === 'response' ? data.action : data.type;
    switch (key) {
      case 'connection':
        this.client.connection = data;
        return this.client.emit('connected', data);
      case 'Subscribe':
        return this.client.emit(`subscribedTo::${data.params.channel}`, data);
      case 'Unsubscribe':
        return this.client.emit(`unsubscribedFrom::${data.params.channel}`, data);
      case 'Event':
        return this.client.emit(`sentEvent::${data.params.data.id}`, data.params);
    }
  }

};

module.exports = SugarClient;
