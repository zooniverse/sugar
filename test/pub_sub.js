// Generated by CoffeeScript 2.7.0
var Bluebird, PubSub, chai, expect, pubSub;

chai = require('chai');

expect = chai.expect;

Bluebird = require('bluebird');

PubSub = require('../lib/pub_sub');

pubSub = new PubSub();

describe('PubSub', function() {
  var subscribeTo, thennableSpy;
  beforeEach(function() {
    return pubSub = new PubSub();
  });
  subscribeTo = function(channel) {
    var callback;
    callback = chai.spy();
    return pubSub.subscribe(channel, callback).then(function() {
      return callback;
    });
  };
  thennableSpy = function() {
    var deferred;
    deferred = Bluebird.defer();
    process.nextTick(function() {
      return deferred.resolve();
    });
    return deferred.promise;
  };
  describe('#subscribe', function() {
    it('should subscribe to a pubsub channel', function() {
      pubSub.redis.sub.subscribeAsync = chai.spy(thennableSpy);
      return subscribeTo('test').then(function() {
        return expect(pubSub.redis.sub.subscribeAsync).to.have.been.called.once.with('test');
      });
    });
    it('should subscribe to a pubsub pattern', function() {
      pubSub.redis.sub.psubscribeAsync = chai.spy(thennableSpy);
      return subscribeTo('test:*').then(function() {
        return expect(pubSub.redis.sub.psubscribeAsync).to.have.been.called.once.with('test:*');
      });
    });
    it('should add a listener to a single channel', function() {
      var fn;
      pubSub.emitter.on = chai.spy(thennableSpy);
      fn = function() {};
      return pubSub.subscribe('test', fn).then(function() {
        return expect(pubSub.emitter.on).to.have.been.called.once.with('test', fn);
      });
    });
    return it('should add a listener to a pattern', function() {
      var fn;
      pubSub.emitter.on = chai.spy(thennableSpy);
      fn = function() {};
      return pubSub.subscribe('test:*', fn).then(function() {
        return expect(pubSub.emitter.on).to.have.been.called.once.with('test:*', fn);
      });
    });
  });
  describe('#unsubscribe', function() {
    it('should unsubscribe from a pubsub channel', function() {
      return subscribeTo('test').then(function(fn) {
        pubSub.redis.sub.unsubscribeAsync = chai.spy(thennableSpy);
        pubSub.unsubscribe('test', fn);
        return expect(pubSub.redis.sub.unsubscribeAsync).to.have.been.called.once.with('test');
      });
    });
    it('should unsubscribe from a pubsub pattern', function() {
      return subscribeTo('test:*').then(function(fn) {
        pubSub.redis.sub.punsubscribeAsync = chai.spy(thennableSpy);
        pubSub.unsubscribe('test:*', fn);
        return expect(pubSub.redis.sub.punsubscribeAsync).to.have.been.called.once.with('test:*');
      });
    });
    it('should remove a listener from a single channel', function() {
      return subscribeTo('test').then(function(fn) {
        pubSub.emitter.removeListener = chai.spy(thennableSpy);
        pubSub.unsubscribe('test', fn);
        return expect(pubSub.emitter.removeListener).to.have.been.called.once.with('test', fn);
      });
    });
    it('should remove a listener from a pattern', function() {
      return subscribeTo('test:*').then(function(fn) {
        pubSub.emitter.removeListener = chai.spy(thennableSpy);
        pubSub.unsubscribe('test:*', fn);
        return expect(pubSub.emitter.removeListener).to.have.been.called.once.with('test:*', fn);
      });
    });
    return it('should only unsubscribe from redis when no subscribers remain', function() {
      return Bluebird.all([subscribeTo('test'), subscribeTo('test')]).then(function(callbacks) {
        var fn1, fn2;
        [fn1, fn2] = callbacks;
        pubSub.redis.sub.unsubscribeAsync = chai.spy(thennableSpy);
        pubSub.unsubscribe('test', fn1);
        expect(pubSub.redis.sub.unsubscribeAsync).to.not.have.been.called();
        pubSub.unsubscribe('test', fn2);
        return expect(pubSub.redis.sub.unsubscribeAsync).to.have.been.called();
      });
    });
  });
  describe('#publish', function() {
    return it('should publish a messsage to a channel', function() {
      pubSub.redis.pub.publishAsync = chai.spy(thennableSpy);
      return pubSub.publish('test', {
        works: true
      }).then(function() {
        return expect(pubSub.redis.pub.publishAsync).to.have.been.called.once.with('test', '{"works":true}');
      });
    });
  });
  return describe('#emitMessage', function() {
    return it('should proxy a redis event to listeners', function() {
      var fn;
      fn = chai.spy();
      return pubSub.subscribe('test', fn).then(function() {
        return pubSub.publish('test', {
          works: true
        }).then(function() {
          return Bluebird.delay(1).then(function() {
            return expect(fn).to.have.been.called.once.with({
              works: true
            });
          });
        });
      });
    });
  });
});
